
import type { HistoricalResult, TotoCombination } from '../types';
import { TOTO_NUMBER_RANGE } from '../types';

// --- Helper Functions ---

export function getNumberFrequencies(results: HistoricalResult[], includeAdditional = false): Record<number, number> {
  const frequencies: Record<number, number> = {};
  for (let i = TOTO_NUMBER_RANGE.min; i <= TOTO_NUMBER_RANGE.max; i++) {
    frequencies[i] = 0;
  }

  results.forEach(result => {
    result.numbers.forEach(num => {
      frequencies[num]++;
    });
    if (includeAdditional && result.additionalNumber) {
      frequencies[result.additionalNumber]++;
    }
  });
  return frequencies;
}

export function getSortedNumbersByFrequency(frequencies: Record<number, number>, order: 'asc' | 'desc'): number[] {
  return Object.entries(frequencies)
    .sort(([, freqA], [, freqB]) => (order === 'desc' ? freqB - freqA : freqA - freqB))
    .map(([numStr]) => parseInt(numStr, 10));
}

// Generates a deterministic sequence of unique numbers
export function getDeterministicSequence(count: number, seed1: number, seed2: number): TotoCombination {
  const picked: Set<number> = new Set();
  let currentNum = seed1;
  const step = seed2 || 7;

  const effectiveStep = (step % TOTO_NUMBER_RANGE.max === 0 && TOTO_NUMBER_RANGE.max > 0) ? 1 : step;

  let iterations = 0;
  const maxIterations = TOTO_NUMBER_RANGE.max * 2;

  while (picked.size < count && iterations < maxIterations) {
    currentNum = (currentNum + effectiveStep -1);
    if (currentNum > TOTO_NUMBER_RANGE.max) {
        currentNum = (currentNum % TOTO_NUMBER_RANGE.max);
        if (currentNum === 0) currentNum = TOTO_NUMBER_RANGE.max;
    }
    if (currentNum < TOTO_NUMBER_RANGE.min) {
        currentNum = TOTO_NUMBER_RANGE.min;
    }

    if (!picked.has(currentNum)) {
      picked.add(currentNum);
    }
    iterations++;
    if (picked.size >= TOTO_NUMBER_RANGE.max && picked.size < count) break;
  }
  return Array.from(picked).slice(0, count).sort((a, b) => a - b);
}

export function ensureUniqueNumbers(numbers: number[], minCount: number = 1, maxCount: number = 24): TotoCombination {
  let uniqueNumbers = Array.from(new Set(numbers.filter(n => n >= TOTO_NUMBER_RANGE.min && n <= TOTO_NUMBER_RANGE.max)));
  uniqueNumbers.sort((a, b) => a - b);

  if (uniqueNumbers.length === 0 && minCount > 0) {
    return [];
  }

  // If fewer than minCount numbers are generated by the core logic, return them as is (deterministic)
  // The algorithm itself is responsible for trying to generate at least minCount if its logic supports it.
  // This helper primarily enforces the maxCount and uniqueness/sorting.
  // If uniqueNumbers.length < minCount, we return the uniqueNumbers we have, rather than padding.
  
  if (uniqueNumbers.length > maxCount) {
    return uniqueNumbers.slice(0, maxCount);
  }
  
  return uniqueNumbers;
}
